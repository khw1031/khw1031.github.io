---
date: 2020-01-09
title: NodeJS 학습 2
description: "NodeJS 공부하기"
template: posts
status: published
categories:
  - javascript
tags:
  - programming
  - node
---

## 필수 패턴

동기식 프로그래밍에서는 특정 문제를 해결하기 위해 정의된 일련의 연속적인 연산 단계들로 코드를 생각하는 것이 익숙하다. 모든 작업은 블로킹이다. 즉, 현재 작업이 완료될 때만 다음 작업을 실행할 수 있다.

비동기식 프로그래밍에서는 파일 읽기 또는 네트워크 요청 수행과 같은 일부 작업을 백그라운드에서 실행할 수 있다. 비동기 작업이 호출되면 이전 작업이 아직 완료되지 않은 경우에도 다음 작업이 즉시 실행된다. 백그라운드에서 보류 중인 작업은 언제든지 완료될 수 있으며, 비동기 호출이 완료되면 적절한 방식으로 반응하도록 전체 애플리케이션을 프로그래밍 해야 한다.

### 콜백 패턴

콜백은 리액터 패턴 핸들러를 구현한 것이다. 콜백은 작업 결과를 전달하기 위해 호출되는 함수이며, 비동기 작업을 처리할 때 반드시 필요하다. 이들은 항상 동기적으로 실행되는 return 명령의 사용을 대신한다.

자바스크립트에서 콜백은 다른 함수에 인수로 전달되는 함수이며, 작업이 완료되면 결과로 호출된다. 함수형 프로그래밍에서는 결과를 전달하는 이러한 방식은 연속 전달 방식(CPS)이라고 한다. 

#### 동기식 연속 전달 방식

```js
function add(a, b) {
  return a + b;
}
```

위와 같은 방식에서 결과는 return 문을 통해 호출자에게 전달되며, 이것을 direct style이라고 한다. 위 함수와 동일한 처리를 연속 전달 방식으로 바꾼 코드는 아래와 같다.

```js
function add(a, b, callback) {
  callback(a + b);
}
```

#### 비동기식 연속 전달 방식

```js
function addAsync(a, b, callback) {
  setTimeout(() => callback(a + b), 100);
}
```

setTimeout은 비동기 작업을 실행시키기 때문에 콜백의 실행이 끝날 때까지 기다리지 않는 대신, 즉시 반환되어 addAsync함수로 제어권을 돌려준다. 비동기 요청이 전달된 후 즉시 제어를 이벤트 루프에 돌려주어 큐에 있는 새로운 이벤트가 처리될 수 있도록 한다.

비동기 작업이 완료되면 비동기 함수에 제공된 콜백에서부터 다시 실행이 시작된다. 실행은 이벤트 루프에서 시작되기 때문에 새로운 스택을 갖는다. 하지만 클로저 덕분에 다른 시점과 다른 위치에서 호출되더라도 비동기 함수의 호출자 컨텍스트를 유지한다.

#### 비 연속 전달 방식의 콜백

```js
const result = [1, 5, 7].map(el => el - 1);
```

콜백은 배열 내의 요소를 반복하는데 사용될 뿐 연산결과를 전달하지 않는다. 이런 경우엔 iterator에 가깝다.

### Node.js 콜백 규칙

#### 콜백은 마지막에

함수가 입력에서 콜백을 허용한다면 맨 마지막 인자로 전달되어야 한다.

```js
fs.readFile(filename, [options], callback);
```

#### 오류는 맨 앞에

Node.js에서 CPS 함수에 의해 생성된 오류는 항상 콜백의 첫 번째 인수로 전달되며, 실제 결과는 두 번째 인수에서부터 전달된다.

```js
fs.readFile("param", "utf8", (err, data) => {});
```

에러가 있는지 항상 확인하는게 좋다. 또 다른 중요한 규칙은 오류는 항상 Error type이어야 한다는 것이다. 즉, 간단한 문자열이나 숫자를 오류 객체로 전달해서는 안된다.

#### 오류 전파

동기식 직접 스타일 함수의 오류 전파는 throw 문을 사용해서 수행되므로 오류가 catch 될 때까지 호출 스택에서 실행된다. 그러나 비동기식 CPS에서 적절한 오류 전달은 오류를 호출 체인의 다음에서 콜백으로 전달하여 수행된다. 에러를 전파할 때 return 문을 사용해 콜백 함수가 호출되는 즉시 함수에서 빠져나와 다른 코드가 실행되지 않도록 해야 한다.

```js
function readJSON(filename, callback) {
  fs.readFile(filename, 'utf8', (err, data) => {
    let parsed;
    if (err) return callback(err); // 오류를 전달하고 현재 함수 종류

    try {
      // 파일의 내용 분석
      parsed = JSON.parse(data);
    } catch (err) {
      // 에러를 catch
      return callback(err);
    }
    // 에러가 없으면 데이터를 전달
    callback(null, parsed);
  })
}
```

#### 캐치되지 않는 예외

만약 try - catch 문이 없다면 JSON.parse()에서 발생하는 예외를 잡을 방법이 없다.

```js
function readJSON(filename, callback) {
  fs.readFile(filename, 'utf8', (err, data) => {
    let parsed;
    if (err) return callback(err);
    callback(null, parsed);
  })
}
```

아래와 같이 전체를 try - catch로 감싸더라도 블록이 동작하는 스택이 콜백이 호출된 스택과 다르기 때문에 제대로 동작하지 않는다. 때문에 아래와 같은 패턴은 안티 패턴이다. 비동기 함수의 실행은 이벤트 루프에 의해 각기 다른 스택에서 실행되기 때문에 트리거 함수가 아닌 이벤트 루프에서 끝난다.

```js
try {
  readJSON(123, (err, result) => console.log(err, result));
} catch (err) {
  console.error(err);
}
```

## 모듈 시스템과 그 패턴

### 노출식 모듈 패턴



<div class="reference__md">
[참고]<br />
Node.js 디자인패턴, Mario Casciaro 저, 영진닷컴
</div>