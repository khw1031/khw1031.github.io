---
title: "TS Utility Types, Promise"
publishedAt: "2024-06-19"
updatedAt: "2024-06-19"
wip: false
summary: ""
---

# 타입스크립트 유틸리티 타입

`Awaited<Type>`: 프로미스를 재귀적으로 언래핑하는 방식의 모델링

```ts
type Awaited<P> = P extends undefined | null ? P extends object & {
  then(outfilled: infer F, ...args: infer _): any
} ? F extends (value: infer V, ...args: infer _) => any ? Awaited<V> : never : P;

check<Awaited<Promise<number>>, number>(true);
check<Awaited<Promise<Promise<number>>>, number>(true);
```

`Partial<Type>`: Type의 모든 프로퍼티가 옵셔널로 설정된 유형 생성

```ts
type Partial<T> = {
  [P in keyof T]?: T[P];
};

check<Partial<{ a: number; b: string }>, { a?: number; b?: string }>(true);
```

`Required<Type>`: Type의 모든 프로퍼티가 필수로 설정된 유형 생성

```ts
type Required<T> = {
  [P in keyof T]-?: T[P];
};

check<Required<{ a?: number; b?: string }>, { a: number; b: string }>(true);
```

`Readonly<Type>`: Type의 모든 프로퍼티가 읽기 전용으로 설정된 유형 생성

```ts
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

check<Readonly<{ a: number; b: string }>, { readonly a: number; readonly b: string }>(true);
```

`Record<Keys, Type>`: 키를 가지고 타입을 생성

```ts
// keyof any = string | number | symbol
type Record<K extends keyof any, T> = {
  [P in K]: T;
};

check<Record<"a" | "b" | "c", number>, { a: number; b: number; c: number }>(
  true
);
```

# Promise

```ts
function delay<T>(time: number, value: T): Promise<T> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(value);
    }, time);
  });
}
```

## Promise.race는 언제 사용하면 좋을까?

```ts
function getFile(name: string): Promise<FileType> {
  return delay(5000, { name, body: "...", size: 100 });
}

// 최대로 기다리고 싶은 TimeOut를 설정하고 싶은 경우
const result = await Promise.race([
  getFile("file1.png"),
  delay(4000, "TimeOut"),
]);

console.log(result);

// 응답이 매우 빠르다면 스켈레톤이나 로딩바를 보여주지 않고 그냥 보여주는 것이 나은 사용자 경험일 수 있음. 이런 경우 race를 사용해서 특정 시간보다 느리게 응답이 오는 경우 우선 로딩바를 보여주고 요청을 계속할 수 있음 
```
